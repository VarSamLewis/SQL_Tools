from sqlglot import parse, transpile
import unittest
import os
import re

def normalize_sql(sql_str):
            
    # Normalize both strings for comparison
    # 1. Convert to lowercase
    # 2. Remove all whitespace

    # Remove all whitespace
    sql_str = re.sub(r'\s+', '', sql_str)
    sql_str = re.sub(r'\n', '', sql_str)  # Remove newlines
    # Convert to lowercase for case-insensitive comparison
    sql_str = sql_str.lower()
    return sql_str
# Custom comparison with specific handling of identity/serial
def compare_sql_structure(actual, expected):
    # Handle the IDENTITY vs SERIAL difference
    actual_normalized = normalize_sql(actual)
    expected_normalized = normalize_sql(expected)

    # Print for debugging
    print("Actual (normalized):", actual_normalized)
    print("Expected (normalized):", expected_normalized)
                
    return actual_normalized == expected_normalized

TSQL_1 = "CREATE TABLE Employees (EmployeeID INT IDENTITY(1,1) PRIMARY KEY, FirstName NVARCHAR(50) NOT NULL, LastName NVARCHAR(50) NOT NULL, Department NVARCHAR(50), HireDate DATE, Salary DECIMAL(10,2), IsActive BIT DEFAULT 1)"

PostgreSQL_1 = "CREATE TABLE Employees (EmployeeID INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY, FirstName VARCHAR(50) NOT NULL, LastName VARCHAR(50) NOT NULL, Department VARCHAR(50), HireDate DATE, Salary DECIMAL(10, 2), IsActive BIT DEFAULT 1)"

TSQL_2 = "INSERT INTO Employees (FirstName, LastName, Department, HireDate, Salary) VALUES ('John', 'Smith', 'Engineering', '2023-01-15', 75000.00), ('Mary', 'Johnson', 'Marketing', '2022-06-01', 65000.00), ('Robert', 'Williams', 'Finance', '2023-03-10', 80000.00)"

PostgreSQL_2 = "INSERT INTO Employees (FirstName, LastName, Department, HireDate, Salary) VALUES ('John', 'Smith', 'Engineering', '2023-01-15', 75000.00), ('Mary', 'Johnson', 'Marketing', '2022-06-01', 65000.00), ('Robert', 'Williams', 'Finance', '2023-03-10', 80000.00)"

TSQL_3 = "SELECT EmployeeID, FirstName + ' ' + LastName AS FullName, Department, FORMAT(HireDate, 'yyyy-MM-dd') AS FormattedHireDate, Salary FROM Employees WHERE Department = 'Engineering' AND HireDate >= '2023-01-01' AND IsActive = 1 ORDER BY Salary DESC"

PostgreSQL_3 = "SELECT EmployeeID, FirstName + ' ' + LastName AS FullName, Department, TO_CHAR(HireDate, 'YYYY-MM-DD') AS FormattedHireDate, Salary FROM Employees WHERE Department = 'Engineering' AND HireDate >= '2023-01-01' AND IsActive = TRUE ORDER BY Salary DESC"

TSQL_4 = "BEGIN TRANSACTION; UPDATE Employees SET Salary = Salary * 1.10, Department = 'Software Engineering' WHERE Department = 'Engineering'; IF @@ROWCOUNT > 0 COMMIT TRANSACTION; ELSE ROLLBACK TRANSACTION"

PostgreSQL_4 = "BEGIN; UPDATE Employees SET Salary = Salary * 1.10, Department = 'Software Engineering' WHERE Department = 'Engineering'; COMMIT"

TSQL_5 = "CREATE PROCEDURE GetEmployeesByDepartment @DepartmentName NVARCHAR(50), @MinimumSalary DECIMAL(10,2) = 0 AS BEGIN SET NOCOUNT ON; SELECT EmployeeID, FirstName, LastName, HireDate, Salary FROM Employees WHERE Department = @DepartmentName AND Salary >= @MinimumSalary AND IsActive = 1 ORDER BY LastName, FirstName; END; EXEC GetEmployeesByDepartment @DepartmentName = 'Marketing', @MinimumSalary = 50000"

PostgreSQL_5 = "CREATE OR REPLACE FUNCTION GetEmployeesByDepartment(department_name VARCHAR(50), minimum_salary DECIMAL(10,2) DEFAULT 0) RETURNS TABLE (EmployeeID INT, FirstName VARCHAR(50), LastName VARCHAR(50), HireDate DATE, Salary DECIMAL(10,2)) AS $$ BEGIN RETURN QUERY SELECT e.EmployeeID, e.FirstName, e.LastName, e.HireDate, e.Salary FROM Employees e WHERE e.Department = department_name AND e.Salary >= minimum_salary AND e.IsActive = TRUE ORDER BY e.LastName, e.FirstName; END; $$ LANGUAGE plpgsql; SELECT * FROM GetEmployeesByDepartment('Marketing', 50000)"

class TestTranspileSQL(unittest.TestCase):
    def test_case1(self):
        # Transpile from T-SQL to PostgreSQL
        PostgreSQL_1_Case = transpile(TSQL_1, read="tsql", write="postgres")[0]

        self.assertTrue(
            compare_sql_structure(normalize_sql(PostgreSQL_1_Case), normalize_sql(PostgreSQL_1)),
            f"SQL structures don't match after normalization.\n\nActual: {normalize_sql(PostgreSQL_1_Case)}\n\nExpected: {normalize_sql(PostgreSQL_1)}"
        )
    def test_case2(self):
        # Transpile from T-SQL to PostgreSQL
        PostgreSQL_2_Case = transpile(TSQL_2, read="tsql", write="postgres")[0]

        self.assertTrue(
            compare_sql_structure(normalize_sql(PostgreSQL_2_Case), normalize_sql(PostgreSQL_2)),
            f"SQL structures don't match after normalization.\n\nActual: {normalize_sql(PostgreSQL_2_Case)}\n\nExpected: {normalize_sql(PostgreSQL_2)}"
        )
    def test_case3(self):
        # Transpile from T-SQL to PostgreSQL
        PostgreSQL_3_Case = transpile(TSQL_3, read="tsql", write="postgres")[0]

        self.assertTrue(
            compare_sql_structure(normalize_sql(PostgreSQL_3_Case), normalize_sql(PostgreSQL_3)),
            f"SQL structures don't match after normalization.\n\nActual: {normalize_sql(PostgreSQL_3_Case)}\n\nExpected: {normalize_sql(PostgreSQL_3)}"
        )
    def test_case4(self):
        # Transpile from T-SQL to PostgreSQL
        PostgreSQL_4_Case = transpile(TSQL_4, read="tsql", write="postgres")[0]

        self.assertTrue(
            compare_sql_structure(normalize_sql(PostgreSQL_4_Case), normalize_sql(PostgreSQL_4)),
            f"SQL structures don't match after normalization.\n\nActual: {normalize_sql(PostgreSQL_4_Case)}\n\nExpected: {normalize_sql(PostgreSQL_4)}"
        )
    def test_case5(self):
        # Transpile from T-SQL to PostgreSQL
        PostgreSQL_5_Case = transpile(TSQL_5, read="tsql", write="postgres")[0]

        self.assertTrue(
            compare_sql_structure(normalize_sql(PostgreSQL_5_Case), normalize_sql(PostgreSQL_5)),
            f"SQL structures don't match after normalization.\n\nActual: {normalize_sql(PostgreSQL_5_Case)}\n\nExpected: {normalize_sql(PostgreSQL_5)}"
        )


def run_tests():
    class VerboseTestResult(unittest.TextTestResult):
        def addSuccess(self, test):
            super().addSuccess(test)
            print(f"{test.id()} - PASS")
        def addFailure(self, test, err):
            super().addFailure(test, err)
            print(f"{test.id()} - FAIL: {err[1]}")
        def addError(self, test, err):
            super().addError(test, err)
            print(f"{test.id()} - ERROR: {err[1]}")

    loader = unittest.TestLoader()
    suite1 = loader.loadTestsFromTestCase(TestTranspileSQL)

    suite = unittest.TestSuite([suite1])
    runner = unittest.TextTestRunner(resultclass=VerboseTestResult, verbosity=2)
    runner.run(suite)

if __name__ == '__main__':
    run_tests()


